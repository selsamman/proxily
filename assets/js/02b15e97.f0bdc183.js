"use strict";(self.webpackChunkproxily_doc=self.webpackChunkproxily_doc||[]).push([[473],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return h}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),p=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=p(e.components);return r.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),d=p(n),h=a,m=d["".concat(l,".").concat(h)]||d[h]||c[h]||i;return n?r.createElement(m,s(s({ref:t},u),{},{components:n})):r.createElement(m,s({ref:t},u))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,s=new Array(i);s[0]=d;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:a,s[1]=o;for(var p=2;p<i;p++)s[p]=n[p];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},6888:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return o},contentTitle:function(){return l},metadata:function(){return p},toc:function(){return u},default:function(){return d}});var r=n(7462),a=n(3366),i=(n(7294),n(3905)),s=["components"],o={sidebar_position:6,title:"React 18"},l=void 0,p={unversionedId:"Features/concurrent",id:"Features/concurrent",isDocsHomePage:!1,title:"React 18",description:"React 18 is currently in alpha.  Features have changed since the alpha started and may continue to change. A beta release is anticipated in the fall of 2021.",source:"@site/docs/Features/concurrent.md",sourceDirName:"Features",slug:"/Features/concurrent",permalink:"/docs/Features/concurrent",editUrl:"https://github.com/selsamman/proxily-doc/edit/master/website/docs/Features/concurrent.md",version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6,title:"React 18"},sidebar:"tutorialSidebar",previous:{title:"Tooling",permalink:"/docs/Features/tools"},next:{title:"Observable API",permalink:"/docs/API/observable"}},u=[{value:"New Features",id:"new-features",children:[]},{value:"Proxily Support",id:"proxily-support",children:[]},{value:"Transitions",id:"transitions",children:[{value:"With setState",id:"with-setstate",children:[]},{value:"With Observables",id:"with-observables",children:[]}]},{value:"Deferred Values",id:"deferred-values",children:[{value:"With setState",id:"with-setstate-1",children:[]},{value:"With Observables",id:"with-observables-1",children:[]}]},{value:"Suspense",id:"suspense",children:[]},{value:"Experimental",id:"experimental",children:[]}],c={toc:u};function d(e){var t=e.components,n=(0,a.Z)(e,s);return(0,i.kt)("wrapper",(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"React 18 is currently in alpha.  Features have changed since the alpha started and may continue to change. A beta release is anticipated in the fall of 2021.")),(0,i.kt)("h2",{id:"new-features"},"New Features"),(0,i.kt)("p",null,"React 18 brings some new capabilities to improve the UX experience.  Those that are relavent to Proxily include:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Concurrent Rendering")," Allows React to break up rendering and prioritize it. It can abandon renders when state changes and rendering components off-screen first while continuing to display a previous version of the component on-screen.  This feature is fully realized when used in conjunction with ",(0,i.kt)("strong",{parentName:"p"},"transitions"),", ",(0,i.kt)("strong",{parentName:"p"},"deferred values")," and ",(0,i.kt)("strong",{parentName:"p"},"suspense")," described below.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Transitions")," are a way to mark state updates that will trigger a transition.  The transition consists of off-screen rendering of components with the updated state while continuing to render components on-screen with previous state.  The off-screen render results are brought on-screen only when the entire transition is complete including rendering suspended elements (see below). ")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Deferred Values")," gives the on-screen version of the component access to the previous state while the off-screen version renders with the updated values.  This is useful to avoid triggering a render of child components in the on-screen version of a component that might lead to lags in responsiveness. ")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Suspense")," allows a stand-in to be displayed while waiting for data that is not yet ready to be displayed.  Importantly,  React continues to render off-screen the suspended content, so it can get deliver it sooner. This effectively allows multiple streams to be fetched simultaneously rather than sequentially."))),(0,i.kt)("h2",{id:"proxily-support"},"Proxily Support"),(0,i.kt)("p",null,'The magic of off-screen rendering is possible because React is capable of "branching" state.  In effect multiple versions of the state are kept such that the on-screen version of the component has access to the original values and off-screen version gets the updated values.  '),(0,i.kt)("p",null,"There are two ways to access the older values in the on-screen version of a component:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Any state updates that are marked as being part of a transition by being wrapped in a ",(0,i.kt)("inlineCode",{parentName:"p"},"startTransition")," callback are always fed to the future off-screen version of component while the transition is in progress.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Previous values can be specifically requested for the benefit of the on-screen version of the component by using a new ",(0,i.kt)("inlineCode",{parentName:"p"},"getDeferredValue")," function. "))),(0,i.kt)("p",null,"Branching is intended to be used with React's native setState or by passing values through component props or contexts.  Proxily provides mechanisms to achieve this functionality with observable state."),(0,i.kt)("h2",{id:"transitions"},"Transitions"),(0,i.kt)("h3",{id:"with-setstate"},"With setState"),(0,i.kt)("p",null,"To use a transition you wrap the code that updates the state that will trigger the transition in a ",(0,i.kt)("strong",{parentName:"p"},"startTransition")," callback:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import {useTransition} from 'React';\n\n// In component ....\nconst [isPending, startTransition] = useTransition();\nconst [something, setSomething] = useState(\"\");\nsomeEvent = () =>\n    startTransition( () => {\n        setSomething(newValue); // New value for transition\n    });\n}\n")),(0,i.kt)("p",null,"At this point React will render off-screen components that depend on the state change and continue to render on-screen components with the state prior to the transition. You can use ",(0,i.kt)("strong",{parentName:"p"},"isPending")," to display an indication that a transition is in progress."),(0,i.kt)("h3",{id:"with-observables"},"With Observables"),(0,i.kt)("p",null,"To use transitions with ",(0,i.kt)("strong",{parentName:"p"},"observable")," state you need to use a slightly different way of starting your transition"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import {useObservableTransition} from 'proxily';\nconst myState = observable({something: \"\"});\n\n// In observer component ...\nconst [isPending, startTransition] = useObservableTransition();\nsomeEvent = () =>\n  startTransition( () => {\n     myState.something = newValue // New value for transition\n  });\n}\n")),(0,i.kt)("p",null,"If you don't need ",(0,i.kt)("strong",{parentName:"p"},"isPending")," use ",(0,i.kt)("strong",{parentName:"p"},"useObservableStartTransition")," to get your ",(0,i.kt)("strong",{parentName:"p"},"startTransition"),". "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import {useObservableStartTransition} from 'proxily';\nconst startTransition = useObservableStartTransition();\n...\n")),(0,i.kt)("h2",{id:"deferred-values"},"Deferred Values"),(0,i.kt)("h3",{id:"with-setstate-1"},"With setState"),(0,i.kt)("p",null,"For values set with ",(0,i.kt)("strong",{parentName:"p"},"useState"),", you can simply request the prior version of a value with ",(0,i.kt)("strong",{parentName:"p"},"getDeferredState"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'  const [text, setText] = useState("hello");\n  const previousText = getDeferredState(text);\n  incrementHandler (e) => setText(e.target.value);\n')),(0,i.kt)("p",null,"Note this applies to the on-screen version of the component. "),(0,i.kt)("h3",{id:"with-observables-1"},"With Observables"),(0,i.kt)("p",null,"For observables you need to request the previous value of an observable with ",(0,i.kt)("strong",{parentName:"p"},"getDeferredObservable")," and wrap the code that sets the value in a ",(0,i.kt)("strong",{parentName:"p"},"setDeferredObservable")," callback."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'  const state = {text: "hello"};\n  ...\n  const [{previousText}, setDeferredObservable] = useDeferredObservable(state);\n  incrementHandler (e) => \n     setDeferredObservable(() => state.text = e.target.value);\n')),(0,i.kt)("h2",{id:"suspense"},"Suspense"),(0,i.kt)("p",null,"Proxily allows a suspense stand-in to be displayed while asynchronously fetched data is still pending. To use this feature:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Put your data fetching in a getter in an observable.  It can parameterize the fetch with other data in the observable and will keep the query up-to-date. "),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"class MyState = {\n  profileId = 1,\n  get profile() {\n    fetch(url + '&id=' + this.profileId).then(r => r.json())\n  }\n}\nstate = observable(new MyState());\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Then tell proxily you want it to be suspendable which will wrap the fetch in the appropriate promise protocol for using Suspense."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"suspendable(MyState, 'profile`)\n")),(0,i.kt)("p",{parentName:"li"},"or with a decorator"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"@suspendable()\nget profile() {\n    fetch(url + '&id=' + this.profileId).then(r => r.json())\n}\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Then just use the value in a ",(0,i.kt)("strong",{parentName:"p"},"<Suspense",">")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"<Suspense fallback={<h1>Loading user...</h1>}>\n   <div>{state.profile.details}</div>\n</Suspense>\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"When you change the profile id in an event handler, the profile getter will be re-evaluated.  The fallback will re-appear until the new profile is fetched.  "),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"someEvent = (e) => state.profileId = e.target.value;\n")),(0,i.kt)("p",{parentName:"li"},"You can keep the old value on screen by wrapping the update in a transition:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"someEvent = (e) => \n    startObservableTransition(() => state.profileId = e.target.value);\n")))),(0,i.kt)("h2",{id:"experimental"},"Experimental"),(0,i.kt)("p",null,"These features have to be considered experimental until React reaches the beta stage.  At present they have been tested in sample applications with React 18,  but Proxily itself still has all of its internal unit testing using prior version of React until a new testing library is released that supports React 18."))}d.isMDXComponent=!0}}]);