"use strict";(self.webpackChunkproxily_doc=self.webpackChunkproxily_doc||[]).push([[453],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return m}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var i=r.createContext({}),c=function(e){var t=r.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=c(e.components);return r.createElement(i.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},b=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,i=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),b=c(n),m=a,h=b["".concat(i,".").concat(m)]||b[m]||p[m]||o;return n?r.createElement(h,s(s({ref:t},u),{},{components:n})):r.createElement(h,s({ref:t},u))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,s=new Array(o);s[0]=b;var l={};for(var i in t)hasOwnProperty.call(t,i)&&(l[i]=t[i]);l.originalType=e,l.mdxType="string"==typeof e?e:a,s[1]=l;for(var c=2;c<o;c++)s[c]=n[c];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}b.displayName="MDXCreateElement"},2809:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return i},metadata:function(){return c},toc:function(){return u},default:function(){return b}});var r=n(7462),a=n(3366),o=(n(7294),n(3905)),s=["components"],l={title:"Observables",sidebar_position:1},i=void 0,c={unversionedId:"Features/observables",id:"Features/observables",isDocsHomePage:!1,title:"Observables",description:"Observing state changes and reacting to them is the core of how Proxily manages state.  The process involves two pieces:",source:"@site/docs/Features/observables.md",sourceDirName:"Features",slug:"/Features/observables",permalink:"/docs/Features/observables",editUrl:"https://github.com/selsamman/proxily-doc/edit/master/website/docs/Features/observables.md",version:"current",sidebarPosition:1,frontMatter:{title:"Observables",sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Why Proxily?",permalink:"/docs/Introduction/how"},next:{title:"Persistence & Serialization",permalink:"/docs/Features/persistence"}},u=[{value:"Observable Objects",id:"observable-objects",children:[]},{value:"Property Accessor Helper",id:"property-accessor-helper",children:[]},{value:"Memoization",id:"memoization",children:[]},{value:"Batching of Reactions",id:"batching-of-reactions",children:[]},{value:"Class Components",id:"class-components",children:[]}],p={toc:u};function b(e){var t=e.components,n=(0,a.Z)(e,s);return(0,o.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Observing state changes and reacting to them is the core of how Proxily manages state.  The process involves two pieces:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Observable")," objects created by ",(0,o.kt)("a",{parentName:"li",href:"../API/observable#makeobservable"},(0,o.kt)("strong",{parentName:"a"},"makeObservable"))," are actually an ES6 proxy that can monitor both references to and mutations of state properties so it handles both tracking of the properties you consume and changes to state.  The nature of observable objects is that they cascade automatically such that all objects referenced become observable as you reference them."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Observers")," are created for each component when you use ",(0,o.kt)("a",{parentName:"li",href:"../API/observable#useObservable"},(0,o.kt)("strong",{parentName:"a"},"useObservables")),".  The observer is notified about both references and mutations of all observable objects.  When a property is mutated that the observer has observed being used a reaction occurs which with ",(0,o.kt)("strong",{parentName:"li"},"useObservables")," means the component is re-rendered")),(0,o.kt)("p",null,"Obsevers may also be created outside of components using ",(0,o.kt)("a",{parentName:"p",href:"../API/observable#observe"},(0,o.kt)("strong",{parentName:"a"},"observe")),' so that other parts of your application can leverage this feature.  For example you could implement an observer that keeps a "last modified" date current or that transmits partial form updates to  server.  Internally ',(0,o.kt)("strong",{parentName:"p"},"persist")," uses observers to know when your state changes and must be saved to local storage."),(0,o.kt)("h2",{id:"observable-objects"},"Observable Objects"),(0,o.kt)("p",null,"Observable objects may contain:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Strings, numbers"),(0,o.kt)("li",{parentName:"ul"},"References to other objects (POJOs or classes)"),(0,o.kt)("li",{parentName:"ul"},"Sets, Maps and Arrays (Arrays are treated as actual arrays)"),(0,o.kt)("li",{parentName:"ul"},"Normal functions, generators and async functions"),(0,o.kt)("li",{parentName:"ul"},"Generators"),(0,o.kt)("li",{parentName:"ul"},"Built in objects provided that you make them ",(0,o.kt)("a",{parentName:"li",href:"../API/utility#nonobservable"},(0,o.kt)("strong",{parentName:"a"},"nonObservable"))),(0,o.kt)("li",{parentName:"ul"},"Cyclic references")),(0,o.kt)("p",null,"The main functions of the observable object include"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Notifying observers of references and mutations"),(0,o.kt)("li",{parentName:"ul"},"Creating new observable objects and replacing references to other objects with them as you make references"),(0,o.kt)("li",{parentName:"ul"},"Handling the memoization of getters and other functions you declare as memoized."),(0,o.kt)("li",{parentName:"ul"},"Binding member functions to the target so than be used without an object reference")),(0,o.kt)("h2",{id:"property-accessor-helper"},"Property Accessor Helper"),(0,o.kt)("p",null,"To get the value of a property you need only reference it.  It is considered a bad practice, however, to mutate the state directly in your component.  Properties should really only be mutated in actions.  The ",(0,o.kt)("a",{parentName:"p",href:"../API/observable#useobservables"},(0,o.kt)("strong",{parentName:"a"},"useObservable"))," property helper creates returns a array with a getter as the first element and a setter as the second, much like setState.  You reference the property in the argument to establish the property being referred to."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const counter = makeObservable({\n  value: 0\n});\n\nfunction App() {\n  useObservables();\n  const [value, setValue] = useObservableProp(counter.value)\n  return (\n    <div>\n      <span>Count: {value}</span>\n      <button onClick={() => setValue(value + 1)}>Increment</button>\n    </div>\n  );\n\n}\n")),(0,o.kt)("p",null,"Be sure to pass the actual property reference (and not just the value) to ",(0,o.kt)("strong",{parentName:"p"},"useObservableProp")," as technically it will refer to the last referenced property. Be sure to also include ",(0,o.kt)("strong",{parentName:"p"},"useObservables")," before calling ",(0,o.kt)("strong",{parentName:"p"},"useObservableProp"),"."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"setValue"))," will be considered an action for tooling such as redux-devtools."),(0,o.kt)("h2",{id:"memoization"},"Memoization"),(0,o.kt)("p",null,"Memoization reduces costly recalculations of computed values based on your state by saving the result and only re-running the calculation when dependent state is changed.  Both getters (akin to selectors) and functions with arguments are supported:  You need only annotate an object function with ",(0,o.kt)("strong",{parentName:"p"},"memoizeObject")," and ",(0,o.kt)("strong",{parentName:"p"},"memoizeClass"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"const state = {\n    counters: [counter1, counter2],\n    sortedCounters: function () {\n        return this.counters.slice(0).sort((a,b) => a.value - b.value);\n    }\n};\nmemoize(state, 'sortedCounters'); \n")),(0,o.kt)("p",null,"or to memoize a method within a class:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"class State {\n    constructor () {\n        this.counters = [new CounterClass(), new CounterClass()];\n    }\n    counters : Array<CounterClass> = [];\n    sortedCounters () {\n        return this.counters.slice(0).sort((a,b) => a.value - b.value);\n    }\n};\nmemoize(State, 'sortedCounters');\n")),(0,o.kt)("p",null,'or with Typescript decorators (with "experimentalDecorators": true in your tsconfig file)'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"class State {\n    constructor () {\n        this.counters = [new CounterClass(), new CounterClass()];\n    }\n    counters : Array<CounterClass> = [];\n    \n    @memoize()\n    sortedCounters () {\n        return this.counters.slice(0).sort((a,b) => a.value - b.value);\n    }\n};\n")),(0,o.kt)("h2",{id:"batching-of-reactions"},"Batching of Reactions"),(0,o.kt)("p",null,"React contains a mechanism to avoid excessive renders in response to state changes.  Basically it schedules state updates which cause renders after user-initiated events complete.  If your onClick handler updates state many times in that code it will result in only one render."),(0,o.kt)("p",null,"In asynchronous situations this is not the case (prior to React 18) since there is no event that React knows about that can be used determine create a boundary around a sequence of state updates.  React 18 will batch and schedule all state updates so for the case of rendering this will no longer be an issue."),(0,o.kt)("p",null,"With Proxily all state mutations are synchronous and never batched.  The way that redundant renders are eliminated is to defer the reaction to the state change (e.g. the render itself) and batch them.    Renders, however, are not the only possible reaction to state change.  Proxily also supports reactions to changes in state through the ",(0,o.kt)("strong",{parentName:"p"},"observe")," call.  This is used internally in the ",(0,o.kt)("strong",{parentName:"p"},"persist")," call to update local storage with state changes."),(0,o.kt)("p",null,"These are the rules for batching reactions to state changes:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"A reaction only occurs when the top level call to a method in an observable component completes such that a reaction will never occur while a series of potentially related state updates complete."),(0,o.kt)("li",{parentName:"ul"},"This batching of nested reactions only applies to synchronous methods.  Asynchronous methods return a promise in response to an await or return after scheduling a callback.  The promise fulfillment or callback is no longer nested within the outer asynchronous function.  Therefore, multiple state updates occurring after await, in a promise fulfillment or in a callback do not cause reactions to be batched."),(0,o.kt)("li",{parentName:"ul"},"To ensure batching of reactions in asynchronous calls you simply need to wrap them in a method call or use ",(0,o.kt)("strong",{parentName:"li"},"groupUpdate"))),(0,o.kt)("h2",{id:"class-components"},"Class Components"),(0,o.kt)("p",null,"If you have class based components you can wrap them in a high order component that calls ",(0,o.kt)("strong",{parentName:"p"},"useObservables")," and passes through properties to the class.  Proxily provides a handy function ",(0,o.kt)("a",{parentName:"p",href:"../API/observable#bindobservables"},(0,o.kt)("strong",{parentName:"a"},"bindObservables"))," that does this for you:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"  class CounterState { // Your state\n        private _value = 0;\n        get value () {\n            return this._value\n        }\n        increment () {this._value++}\n  }\n    \n  const state = makeObservable({  // Your Observable state\n        counter: new CounterState()\n  });\n    \n  // Class Based Component\n  class CounterClass extends React.Component<{counter : CounterState}> {\n        render () {\n            const {value, increment} = this.props.counter;\n            return (\n                <div>\n                    <span>Count: {value}</span>\n                    <button onClick={increment}>Increment</button>2\n                </div>\n            );\n        }\n    }\n\n  // Wrap class-based component to make properties observable\n  const Counter = bindObservables(CounterClass);\n    \n  function App () {\n        return (\n            <Counter counter={state.counter}/>\n        );\n  }\n")))}b.isMDXComponent=!0}}]);