"use strict";(self.webpackChunkproxily_doc=self.webpackChunkproxily_doc||[]).push([[473],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return d}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),p=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=p(e.components);return r.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),h=p(n),d=a,m=h["".concat(l,".").concat(d)]||h[d]||c[d]||i;return n?r.createElement(m,o(o({ref:t},u),{},{components:n})):r.createElement(m,o({ref:t},u))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var p=2;p<i;p++)o[p]=n[p];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},6888:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return p},toc:function(){return u},default:function(){return h}});var r=n(7462),a=n(3366),i=(n(7294),n(3905)),o=["components"],s={sidebar_position:6,title:"React 18"},l=void 0,p={unversionedId:"Features/concurrent",id:"Features/concurrent",isDocsHomePage:!1,title:"React 18",description:"New Features",source:"@site/docs/Features/concurrent.md",sourceDirName:"Features",slug:"/Features/concurrent",permalink:"/docs/Features/concurrent",editUrl:"https://github.com/selsamman/proxily-doc/edit/master/website/docs/Features/concurrent.md",version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6,title:"React 18"},sidebar:"tutorialSidebar",previous:{title:"Tooling",permalink:"/docs/Features/tools"},next:{title:"Observable API",permalink:"/docs/API/observable"}},u=[{value:"New Features",id:"new-features",children:[]},{value:"Proxily Support",id:"proxily-support",children:[]},{value:"Transitions",id:"transitions",children:[{value:"With setState",id:"with-setstate",children:[]},{value:"With Observables",id:"with-observables",children:[]},{value:"Keeping the UI Responsive with getCurrentValue",id:"keeping-the-ui-responsive-with-getcurrentvalue",children:[]},{value:"Putting it all together",id:"putting-it-all-together",children:[]}]},{value:"Suspense",id:"suspense",children:[]}],c={toc:u};function h(e){var t=e.components,n=(0,a.Z)(e,o);return(0,i.kt)("wrapper",(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"new-features"},"New Features"),(0,i.kt)("p",null,"React 18 brings some new capabilities to improve the UX experience. Concurrent Rendering allows React to break up rendering and prioritize it. It can abandon renders when state changes and the rendering components off-screen in preparation for a transition while continuing to display a previous version of  components on-screen.  This feature is fully realized when used in conjunction with ",(0,i.kt)("strong",{parentName:"p"},"transitions"),", ",(0,i.kt)("strong",{parentName:"p"},"deferred values")," and ",(0,i.kt)("strong",{parentName:"p"},"suspense")," described below."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Transitions")," are a way to mark state updates that will trigger a transition.  The transition consists of off-screen rendering of components with the updated state while continuing to render components on-screen with previous state.  The off-screen render results are brought on-screen only when the entire transition is complete including rendering suspended elements (see below). ")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Deferred Values")," gives the on-screen version of the component access to the previous state while the off-screen version renders with the updated values.  This is useful to avoid triggering a render of child components in the on-screen version of a component that might lead to lags in responsiveness. ")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Suspense")," allows a stand-in to be displayed while waiting for data that is not yet ready to be displayed.  Importantly,  React continues to render off-screen the suspended content, so it can get deliver it sooner. This effectively allows multiple streams to be fetched simultaneously rather than sequentially."))),(0,i.kt)("h2",{id:"proxily-support"},"Proxily Support"),(0,i.kt)("p",null,'The magic of off-screen rendering is possible because React is capable of "branching" state.  In effect multiple versions of the state are kept such that the on-screen version of the component has access to the original values and the off-screen version gets the updated values.  '),(0,i.kt)("p",null,"There are two ways to access the older values in the on-screen version of a component:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Any state updates that are marked as being part of a transition by being wrapped in a ",(0,i.kt)("inlineCode",{parentName:"p"},"startTransition")," callback are always fed to the future off-screen version of component while the transition is in progress.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Previous values can be specifically requested for the benefit of the on-screen version of the component by using a new ",(0,i.kt)("inlineCode",{parentName:"p"},"getDeferredValue")," function. "))),(0,i.kt)("p",null,'This state "branching" is intended to be used with React\'s native setState or by passing values through component props or contexts.  Proxily provides mechanisms to achieve this functionality with observable state.'),(0,i.kt)("h2",{id:"transitions"},"Transitions"),(0,i.kt)("h3",{id:"with-setstate"},"With setState"),(0,i.kt)("p",null,"To use a transition you wrap the code that updates the state that will trigger the transition in a ",(0,i.kt)("strong",{parentName:"p"},"startTransition")," callback:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import {useTransition} from 'React';\n\n// In component ....\nconst [isPending, startTransition] = useTransition();\nconst [something, setSomething] = useState(\"\");\nsomeEvent = () =>\n    startTransition( () => {\n        setSomething(newValue); // New value for transition\n    });\n}\n")),(0,i.kt)("p",null,"At this point React will render off-screen components that depend on the state change and continue to render on-screen components with the state prior to the transition. You can use ",(0,i.kt)("strong",{parentName:"p"},"isPending")," to display an indication that a transition is in progress."),(0,i.kt)("h3",{id:"with-observables"},"With Observables"),(0,i.kt)("p",null,"Transitions with ",(0,i.kt)("strong",{parentName:"p"},"observable")," in Proxily deal with your entire state and allow it to be branched. The way of using it is quite similar, just substituting useObservableTransition for useTransition."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import {useObservableTransition} from 'proxily';\nconst myState = observable({something: \"\"});\n\n// In observer component ...\nconst [isPending, startTransition] = useObservableTransition();\nsomeEvent = () =>\n  startTransition( () => {\n     myState.something = newValue // New value for transition\n  });\n}\n")),(0,i.kt)("p",null,'When you update your state within the startTransition you are "branching" your state and Proxily will provide the old state the component currently on the screen and the current state to another copy of the component that React renders off-screen.'),(0,i.kt)("p",null,"If you don't to update the component currently on the screen while the off-screen rendering is progress (e.g. don't need ",(0,i.kt)("strong",{parentName:"p"},"isPending")," and won't be using ",(0,i.kt)("strong",{parentName:"p"},"getCurrentValue")," you may use ",(0,i.kt)("strong",{parentName:"p"},"useObservableStartTransition")," to get your ",(0,i.kt)("strong",{parentName:"p"},"startTransition"),".   "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import {useObservableStartTransition} from 'proxily';\nconst startTransition = useObservableStartTransition();\n...\n")),(0,i.kt)("h3",{id:"keeping-the-ui-responsive-with-getcurrentvalue"},"Keeping the UI Responsive with getCurrentValue"),(0,i.kt)("p",null,"You don't have to do anything special to take advantage of this advance off-screen rendering unless you need access to the current value of your state.  This might be, for example if you are providing feedback to the user on input they may have provided. "),(0,i.kt)("p",null,"In case you want to get the current value of the state rather than the stale value that is normally provided during the transition you can access it using ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"getCurrentValue")),".  "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"const updatedText = getCurrentValue(state, state => state.text);\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"getCurrentValue"))," is serves a similar purpose as ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"useDeferredValue"))," except that:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"It must be used along with a transition"),(0,i.kt)("li",{parentName:"ul"},"It provides the eventual state rather than the previous state")),(0,i.kt)("h3",{id:"putting-it-all-together"},"Putting it all together"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'const state = observable({\n    searchText: ""\n    articles : []\n});\n\nfunction SearchList () {\n const [,startTransition] = useObservableTransition();\n const change(e) => startTransition(() => state.result.text = e.target.value;\n return (\n     <>\n        <input value={getCurrentValue(state, state => state.searchText)}\n               onChange={change}/>\n        <Articles search={state.searchText}/>       \n     </>\n )\n}\nexport observer(SearchList);\n')),(0,i.kt)("p",null,"Here is what will happen:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"When you update search results as part of the startTransition callback you are letting both React and Proxily know that a transition is beginning"),(0,i.kt)("li",{parentName:"ul"},"Proxily will update your state immediately but keep the original value around until the transition is complete."),(0,i.kt)("li",{parentName:"ul"},"React will immediately re-render the on-screen component and Proxily will provide the component with the original value of the data because the transition is still in progress."),(0,i.kt)("li",{parentName:"ul"},"However, input field sees the current value through ",(0,i.kt)("strong",{parentName:"li"},"getCurrentValue")," "),(0,i.kt)("li",{parentName:"ul"},"The Articles component is passed the old search value and assuming it uses memo it won't re-render at that point."),(0,i.kt)("li",{parentName:"ul"},"React will render the component again off-screen. Proxily will provide the new value for searchText so Articles will now render but at a lower priority.  "),(0,i.kt)("li",{parentName:"ul"},"The lower priority means that if you type more search criteria into the input the rendering will be cut short once the current article renders and the whole process repeats itself.")),(0,i.kt)("p",null,"Had we not used the transition the screen would not be updated until the articles all rendered."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Be sure to use ",(0,i.kt)("strong",{parentName:"p"},"useObservableTransition")," rather than ",(0,i.kt)("strong",{parentName:"p"},"useObservableStartTransition")," since you need to re-render the component to show the updated input value while the off-screen rendering takes place.")),(0,i.kt)("h2",{id:"suspense"},"Suspense"),(0,i.kt)("p",null,"Proxily allows a suspense stand-in to be displayed while asynchronously fetched data is still pending. To use this feature:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Put your data fetching in a getter in an observable.  It can parameterize the fetch with other data in the observable and will keep the query up-to-date. "),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"class MyState = {\n  profileId = 1,\n  get profile() {\n    fetch(url + '&id=' + this.profileId).then(r => r.json())\n  }\n}\nstate = observable(new MyState());\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Then tell proxily you want it to be suspendable which will wrap the fetch in the appropriate promise protocol for using Suspense."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"suspendable(MyState, 'profile`)\n")),(0,i.kt)("p",{parentName:"li"},"or with a decorator"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"@suspendable()\nget profile() {\n    fetch(url + '&id=' + this.profileId).then(r => r.json())\n}\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Then just use the value in a ",(0,i.kt)("strong",{parentName:"p"},"<Suspense",">")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"<Suspense fallback={<h1>Loading user...</h1>}>\n   <div>{state.profile.details}</div>\n</Suspense>\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"When you change the profile id in an event handler, the profile getter will be re-evaluated.  The fallback will re-appear until the new profile is fetched.  "),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"someEvent = (e) => state.profileId = e.target.value;\n")),(0,i.kt)("p",{parentName:"li"},"You can keep the old value on screen by wrapping the update in a transition:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"someEvent = (e) => \n    startObservableTransition(() => state.profileId = e.target.value);\n")))))}h.isMDXComponent=!0}}]);