"use strict";(self.webpackChunkproxily_doc=self.webpackChunkproxily_doc||[]).push([[672],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return d}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),m=c(n),d=r,h=m["".concat(l,".").concat(d)]||m[d]||p[d]||o;return n?a.createElement(h,i(i({ref:t},u),{},{components:n})):a.createElement(h,i({ref:t},u))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},877:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return u},default:function(){return m}});var a=n(7462),r=n(3366),o=(n(7294),n(3905)),i=["components"],s={title:"Transactions",sidebar_position:4},l=void 0,c={unversionedId:"Features/transactions",id:"Features/transactions",isDocsHomePage:!1,title:"Transactions",description:"Use Cases",source:"@site/docs/Features/transactions.md",sourceDirName:"Features",slug:"/Features/transactions",permalink:"/proxily/docs/Features/transactions",editUrl:"https://github.com/selsamman/proxily-doc/edit/master/website/docs/Features/transactions.md",version:"current",sidebarPosition:4,frontMatter:{title:"Transactions",sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Asynchronous",permalink:"/proxily/docs/Features/async"},next:{title:"Tooling",permalink:"/proxily/docs/Features/tools"}},u=[{value:"Use Cases",id:"use-cases",children:[]},{value:"Creating a Transaction",id:"creating-a-transaction",children:[]},{value:"Transaction Object",id:"transaction-object",children:[]},{value:"How time positioning in transactions works",id:"how-time-positioning-in-transactions-works",children:[]},{value:"Requesting incremental time positioning",id:"requesting-incremental-time-positioning",children:[]},{value:"Default Transaction",id:"default-transaction",children:[]},{value:"Update Anomalies",id:"update-anomalies",children:[]}],p={toc:u};function m(e){var t=e.components,n=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h3",{id:"use-cases"},"Use Cases"),(0,o.kt)("p",null,"Forking the state is not a common feature of state management libraries.  To understand the benefits, here are a few common use cases:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"Asynchronous updates"))," - Often updates from the server take several calls to complete and data is delivered in pieces.  Rather than putting intermediate data in the store which can impact integrity most applications will store up the results and then update the state when all calls have succeeded. Forking the state allows the state to be updated as each call to the server is completed.  If the operation as a whole fails, the saga controlling the server interaction and the partial updates can both be cancelled.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"Complex User Interactions"))," - Sometimes a user interface requires a series of steps to complete.  Rather than updating the state at each step which is the simplest solution, components often store intermediate state locally until the steps are complete. With state forking the application doesn't need to worry about this and can use the normal process for updating the pieces of the state as the user goes along, knowing that the updates won't be visible until the end. Examples might include:"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Modal dialogs that implement a cancel / OK button"),(0,o.kt)("li",{parentName:"ul"},"Creating a new chat message which must have a recipient, subject and text to be complete"),(0,o.kt)("li",{parentName:"ul"},"Filling out a form where there are required fields"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"Undo/Redo"))," - Some user interfaces require an undo/redo button. Other usually implement this through snapshots and patches which potentially impacts the entire store. Proxily can limit the scope of the undo/redo to a single set of actions using transactions.  Undoing an operation would not, for example, undo any other changes to the store made as result of unrelated synchronous operations that happened to occur during the course of user interaction."))),(0,o.kt)("h3",{id:"creating-a-transaction"},"Creating a Transaction"),(0,o.kt)("p",null,"To use a transaction in a component follow these steps:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Place ",(0,o.kt)("strong",{parentName:"li"},"useObservables")," as usual at the start of your render"),(0,o.kt)("li",{parentName:"ul"},"Create the transaction with ",(0,o.kt)("strong",{parentName:"li"},"useTransaction")),(0,o.kt)("li",{parentName:"ul"},"Call ",(0,o.kt)("strong",{parentName:"li"},"useTransactable")," to get a transactable copy of the data you wish to participate in the transaction. Proxily will automatically make subordinate objects transactable as you reference them from the copy."),(0,o.kt)("li",{parentName:"ul"},"Call ",(0,o.kt)("strong",{parentName:"li"},"commit()")," or ",(0,o.kt)("strong",{parentName:"li"},"rollback()")," on the transaction when the user interaction is complete and you wish the changes in your copies of the data to be reflect back to the original")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},'function UpdateCustomer ({customer} : {customer : Customer}) {\n    useObservables();\n    const updateAddressTxn = useTransaction();\n    customer = useTransactable(customer, updateAddressTxn);\n    const {name, phone, setName, setPhone} = customer;\n    return (\n        <>\n            <input type="text" value={name} \n                   onChange={(e) => setName(e.target.value)} />\n            <input type="text" value={phone} \n                   onChange={(e) => setPhone(e.target.value)} />\n            <button onClick={() => updateAddressTxn.commit()} >Commit</button>\n            <button onClick={() => updateAddressTxn.rollback()} >Rollback</button>\n        </>\n    )\n}\n\n')),(0,o.kt)("p",null,"Sometimes a transaction may span multiple components.  In that case you can either create the transaction using ",(0,o.kt)("strong",{parentName:"p"},"useTransaction")," in the highest level component and pass it down via parameters or use ",(0,o.kt)("strong",{parentName:"p"},"\\<TransactionProvider",">")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"import {TransactionProvider} from 'proxily';\nfunction App () {\n    return (\n        <TransactionProvider>\n            <UpdateCustomer customer={customer} />\n        </TransactionProvider>\n    )\n}\n")),(0,o.kt)("p",null,"With ",(0,o.kt)("strong",{parentName:"p"},"\\<TransactionProvider",">")," you can then reference the transaction in your transaction with useContext rather than creating it in the component"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"import {TransactionContext} from 'proxily';\n...\nconst updateAddressTxn = useContext(TransactionContext);\n")),(0,o.kt)("h3",{id:"transaction-object"},"Transaction Object"),(0,o.kt)("p",null,"The transaction objected produced by new Transaction has a number of functions and properties available to it."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("em",{parentName:"strong"},"updateSequence"))," - An update sequence number representing the current state.  This value can be used to remember a point in time, and then you can roll back the state to that point in time using ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("em",{parentName:"strong"},"rollTo")),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("em",{parentName:"strong"},"rollTo(updateSequence : number)"))," - Roll back or forward the transaction to a specific point."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("em",{parentName:"strong"},"rollback()"))," - Roll back the transaction by discarding all changes since the creation or the last rollback."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("em",{parentName:"strong"},"commit()"))," - Commit the changes in the transaction, so they are visible outside the transaction."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("em",{parentName:"strong"},"undo()"))," - Go back to the previous sequence number that represents the state at the start of a call to the outermost function."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("em",{parentName:"strong"},"redo()"))," - Go forward to the next sequence number that represents the state at the start of a call to the outermost function."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("em",{parentName:"strong"},"canUndo"))," - returns true if the undo function can be executed"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("em",{parentName:"strong"},"canRedo"))," - returns true if the redo function can be executed")),(0,o.kt)("h3",{id:"how-time-positioning-in-transactions-works"},"How time positioning in transactions works"),(0,o.kt)("p",null,"Time position (undo/redo/rollTo) is implemented by internally creating an array of function pairs that can undo/redo each update.  The current position in that array (normally the last entry) is the ",(0,o.kt)("strong",{parentName:"p"},"*updateSequence")," property in the Transaction object.  When you position backwards (undo() or rollback() to a lower number), Proxily executes the functions one at a time until you reach the desired sequence number.  At that point one of two things can happen:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"You reposition again"),(0,o.kt)("li",{parentName:"ul"},"You preform a state update")),(0,o.kt)("p",null,"In the later case the current position becomes the last entry in this array by deleting all later entries.  Thus, if you ",(0,o.kt)("strong",{parentName:"p"},"undo")," or ",(0,o.kt)("strong",{parentName:"p"},"rollTo")," and make further state changes you can never go further forward in time."),(0,o.kt)("p",null,"A ",(0,o.kt)("strong",{parentName:"p"},"rollback")," does not use the array of undo/redo functions.  Instead, it simply updates all the of the target objects to the state of main store."),(0,o.kt)("h3",{id:"requesting-incremental-time-positioning"},"Requesting incremental time positioning"),(0,o.kt)("p",null,"Since implementing the internal undo/redo list has a performance impact on memory it is not turned on by default.  To enable it you create a transaction with TimePositioning as an option:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"const txn = useTransaction({timePositioning: true});\n")),(0,o.kt)("h3",{id:"default-transaction"},"Default Transaction"),(0,o.kt)("p",null,"There is a default transaction that is always present.  Normally it is created when you make your first observable object.  If you wish to include time positioning throughout your application you can pre-create the default transaction before any ",(0,o.kt)("strong",{parentName:"p"},"makeObservable")," or ",(0,o.kt)("strong",{parentName:"p"},"persist")," calls"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"Transaction.createDefaultTransaction({timePositioning: true})\n")),(0,o.kt)("p",null,"And you can reference the default transaction like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"Transaction.defaultTransaction.undo();\n")),(0,o.kt)("h3",{id:"update-anomalies"},"Update Anomalies"),(0,o.kt)("p",null,"When you commit you override any changes made outside the transaction that are made during the timespan between creating the transaction and committing.  This applies, however, only to data (objects) that you reference in the transaction.  Therefore, we recommend that you ensure that overlapping parts of the state are not simultaneously updated inside and outside the transaction."),(0,o.kt)("p",null,"Proxily applies a very simple forking mechanism to transactions."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Proxily makes a copy of each object (using ",(0,o.kt)("strong",{parentName:"li"},"Object.create")," and ",(0,o.kt)("strong",{parentName:"li"},"Object.assign"),") as you reference it.  This includes built-ins such as Array, Map, Set and Date.  This copy becomes your new proxy during the course of the transaction."),(0,o.kt)("li",{parentName:"ul"},"When you commit it copies the data back to the original"),(0,o.kt)("li",{parentName:"ul"},"When you roll back it copies the data from the original to the transaction copy")),(0,o.kt)("p",null,"While this works in most circumstances there are some anomalies to be aware of:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Under some circumstances changes stemming from the commit will be moot.  For example if you update the address of a customer that you deleted outside the transaction, the customer will remain deleted even if you commit the changes to update its address."),(0,o.kt)("li",{parentName:"ul"},"Since Proxily copes the entirety of an Array, Map, Set and Date objects, any element updated in a transaction will overwrite any other changes in that object made outside the transaction."),(0,o.kt)("li",{parentName:"ul"},"Changes made outside the transaction are isolated from the transaction as long they occur after the data has been referenced in the transaction.  This general works well since one usually creates the transaction in the course of the first render.")),(0,o.kt)("h1",{id:"redux-devtools"},"Redux-DevTools"),(0,o.kt)("p",null,"Proxily supports redux-devtools. We recommend only using in development mode and not in production since it stores all previous states in memory which can be more expensive than it would be with Redux.  To use it call ",(0,o.kt)("strong",{parentName:"p"},"configureReduxDevTools")," at the start of your app and ",(0,o.kt)("strong",{parentName:"p"},"initReduxDevTools")," after your state has been initialized."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"configureReduxDevTools();\nconst toDoList = makeObservable(new ToDoList();\ninitReduxDevTools();\n")),(0,o.kt)("p",null,"There are some things to note about using redux-devtools:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"You can have multiple roots for your state that will appear in the tool"),(0,o.kt)("li",{parentName:"ul"},"Each time you call makeObservable (or use ObservableContextProvider) you are creating a root"),(0,o.kt)("li",{parentName:"ul"},"When you time travel all roots will be updated to the state they were in when a particular action was fired"),(0,o.kt)("li",{parentName:"ul"},"Because in Proxily you can create observable objects on the fly and discard them when no longer needed, time travelling backwards or forwards cannot re-create the objects for you."),(0,o.kt)("li",{parentName:"ul"},'If you wish to have the same "single source of truth" for time-travel in redux-devtools as you have in Redux then you need create a single makeObservable object at the top of your app just as you would do with redux.')))}m.isMDXComponent=!0}}]);