"use strict";(self.webpackChunkproxily_doc=self.webpackChunkproxily_doc||[]).push([[692],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return d}});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=r.createContext({}),l=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=l(e.components);return r.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,c=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),m=l(n),d=o,h=m["".concat(c,".").concat(d)]||m[d]||p[d]||a;return n?r.createElement(h,s(s({ref:t},u),{},{components:n})):r.createElement(h,s({ref:t},u))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,s=new Array(a);s[0]=m;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:o,s[1]=i;for(var l=2;l<a;l++)s[l]=n[l];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},5927:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return i},contentTitle:function(){return c},metadata:function(){return l},toc:function(){return u},default:function(){return m}});var r=n(7462),o=n(3366),a=(n(7294),n(3905)),s=["components"],i={sidebar_position:2,title:"Core Concepts",id:"core"},c=void 0,l={unversionedId:"Introduction/core",id:"Introduction/core",isDocsHomePage:!1,title:"Core Concepts",description:"Observables",source:"@site/docs/Introduction/core.md",sourceDirName:"Introduction",slug:"/Introduction/core",permalink:"/docs/Introduction/core",editUrl:"https://github.com/selsamman/proxily-doc/edit/master/website/docs/Introduction/core.md",version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,title:"Core Concepts",id:"core"},sidebar:"tutorialSidebar",previous:{title:"Usage",permalink:"/docs/Introduction/intro"},next:{title:"Why Proxily?",permalink:"/docs/Introduction/how"}},u=[{value:"Observables",id:"observables",children:[]},{value:"Stores, Actions, Selectors",id:"stores-actions-selectors",children:[{value:"POJOs",id:"pojos",children:[]},{value:"Classes",id:"classes",children:[]},{value:"Your App, Your Choice",id:"your-app-your-choice",children:[]}]}],p={toc:u};function m(e){var t=e.components,n=(0,o.Z)(e,s);return(0,a.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"observables"},"Observables"),(0,a.kt)("p",null,'Proxily tracks references to state while your component renders.  It then ensures that your component is re-rendered anytime the referenced state properties change.  You make your state "observable" with ',(0,a.kt)("a",{parentName:"p",href:"/docs/API/observable#makeobservable"},(0,a.kt)("strong",{parentName:"a"},"makeObservable"))," and then ask Proxily to track references with ",(0,a.kt)("a",{parentName:"p",href:"../API/observable#useobservables"},(0,a.kt)("strong",{parentName:"a"},"useObservables")),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"class CounterState {  // Your State\n    value = 0;  \n    increment () {this.value++}\n}\n\nconst state = makeObservable({  // Make it observable\n    counter: new CounterState()\n});\n\nfunction Counter({counter} : {counter : CounterState}) {\n    useObservables(); // Track references\n    const {value, increment} = counter;\n    return (\n        <div>\n            <span>Count: {value}</span>\n            <button onClick={increment}>Increment</button>\n        </div>\n    );\n}\n\nfunction App () {\n    return (\n        <Counter counter={state.counter}/>\n    );\n}\n")),(0,a.kt)("p",null,"These two calls, ",(0,a.kt)("strong",{parentName:"p"},"makeObservable")," and ",(0,a.kt)("strong",{parentName:"p"},"useObservables")," are really all you need for basic state management with React.  If you want to see a more complete exampled, head over to the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/selsamman/proxily_react_todo_classic"},"classic redux-style Todo app"),".  Otherwise, continue on."),(0,a.kt)("h2",{id:"stores-actions-selectors"},"Stores, Actions, Selectors"),(0,a.kt)("p",null,"Proxily uses standard Javascript language features to define the traditional elements of state management:  "),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Stores")," - A store in Proxily is simply an object that you have made observable and is usually the root object in your state.  It may contain cyclic references, and you may have multiple observable root objects.  You can create global stores or local stores that are only needed for a single component or small group of components. You can pass around the root of the store or any part of the store to your components as properties, contexts or simply import it.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Actions")," - Actions are usually responses to users interacting with your component. Any function that is a member of an observable object can be an action.  Proxily tracks the nesting of calls such that the top level function you call is considered to be the action for purposes of tooling and batching of reactions. You may also spin off asynchronous actions that use promises or that schedule tasks using Redux-saga. ")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Selectors")," - A selector is simply a Javascript ",(0,a.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get"},"getter")," method on an observable object.  You may optionally ",(0,a.kt)("a",{parentName:"p",href:"../Features/observables#memoization"},"memoize")," the selector for better performance on expensive calculations (e.g. sorts and filters)."))),(0,a.kt)("p",null,"While the proxily doesn't have a fixed opinion on how you set these up, you should pick a pattern and stick to it so that you have a consistent approach to managing state throughout your application.  The two main options are using POJOs for state, with separate actions and selectors or classes which combine them all together."),(0,a.kt)("h3",{id:"pojos"},"POJOs"),(0,a.kt)("p",null,'With traditional state management systems such as Redux you create your state using "plane old javascript objects" (POJOs), define reducers to generate a new state, and actions which are dispatched to invoke the reducers.  In Proxily you don\'t need reducers as your actions modify state directly.  You can, however, keep your state as POJOs and define your actions and selectors separately thus keeping a more traditional taxonomy:'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"    const store = persist({\n        counter: {\n            value: 0\n        }\n    }, {});\n    const actions = makeObservable({\n        increment () {\n            store.counter.value++\n        }\n    })\n    const selectors = makeObservable({\n        get value () {\n            return store.counter.value;\n        }\n    })\n    function App() {\n        useObservables();\n        const {value} = selectors;\n        const {increment} = actions;\n        return (\n            <div>\n                <span>Count: {value}</span>\n                <button onClick={increment}>Increment</button>\n            </div>\n        );\n    }\n")),(0,a.kt)("p",null,"Notice that we added ",(0,a.kt)("strong",{parentName:"p"},"persist")," here to save and restore the state to local storage.  In addition to saving and restoring your state to local or session storage, ",(0,a.kt)("strong",{parentName:"p"},"persist")," also makes the object observable."),(0,a.kt)("h3",{id:"classes"},"Classes"),(0,a.kt)("p",null,"Classes, as we saw at the start of the chapter, offer a more compact way of expressing the problem domain. They do, however, have some challanges:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"They are harder to serialize"),(0,a.kt)("li",{parentName:"ul"},'Member functions must always be invoked as an object reference to set "this" correctly')),(0,a.kt)("p",null,"Proxily solves both issues. "),(0,a.kt)("p",null,"For serialization and persistence to work just provide list of the classes:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"    const state = persist({\n        counter: new CounterState()\n    }, {classes: [CounterState]});\n")),(0,a.kt)("p",null,"As to not requiring an object reference for member functions, you may have wondered how our class-based example got away with destructuring ",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("em",{parentName:"strong"},"increment"))," from ",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("em",{parentName:"strong"},"counter"))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"const {value, increment} = counter;\n")),(0,a.kt)("p",null,"and then using it without an object reference (e.g. counter.increment())"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"<button onClick={increment}>Increment</button>\n")),(0,a.kt)("p",null,"Proxily binds all members of an observable object to the target. This takes away one of the key pain-points of using classes."),(0,a.kt)("h3",{id:"your-app-your-choice"},"Your App, Your Choice"),(0,a.kt)("p",null,"The choice of using POJOs or classes for your state is yours to make and Proxily works equally well with both.  Classes do, however, provide some tangible benefits:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"State and the code to modify that state are bound together, so it is clear which code is mutating which state.  This can be enforced using private properties.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Classes are the most direct way to define types in Typescript.  They combine describing and typing state with assigning initial values, taking advantage of inference in many cases. ")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Defining initial values within the class ensures objects are initialized correctly.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"There is one single interface for both consuming and modifying any object in your state so there is no need to import a separate interface with actions and selectors. ")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"You don't need to pass instance identifiers in your actions. ")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Class names are attached to your data making it possible to ",(0,a.kt)("a",{parentName:"p",href:"../Features/tools#logging"},"log")," both the class and method when state is mutated."))))}m.isMDXComponent=!0}}]);