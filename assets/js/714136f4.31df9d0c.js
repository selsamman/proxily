"use strict";(self.webpackChunkproxily_doc=self.webpackChunkproxily_doc||[]).push([[692],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return d}});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),m=c(n),d=o,h=m["".concat(l,".").concat(d)]||m[d]||p[d]||a;return n?r.createElement(h,s(s({ref:t},u),{},{components:n})):r.createElement(h,s({ref:t},u))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,s=new Array(a);s[0]=m;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:o,s[1]=i;for(var c=2;c<a;c++)s[c]=n[c];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},5927:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return i},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return u},default:function(){return m}});var r=n(7462),o=n(3366),a=(n(7294),n(3905)),s=["components"],i={sidebar_position:2,title:"Core Concepts",id:"core"},l=void 0,c={unversionedId:"Introduction/core",id:"Introduction/core",isDocsHomePage:!1,title:"Core Concepts",description:"Observables",source:"@site/docs/Introduction/core.md",sourceDirName:"Introduction",slug:"/Introduction/core",permalink:"/proxily/docs/Introduction/core",editUrl:"https://github.com/selsamman/proxily-doc/edit/master/website/docs/Introduction/core.md",version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,title:"Core Concepts",id:"core"},sidebar:"tutorialSidebar",previous:{title:"Usage",permalink:"/proxily/docs/Introduction/intro"},next:{title:"How it Works",permalink:"/proxily/docs/Introduction/how"}},u=[{value:"Observables",id:"observables",children:[]},{value:"Stores, Actions, Selectors",id:"stores-actions-selectors",children:[{value:"Plane Old Javascript",id:"plane-old-javascript",children:[]}]},{value:"Classes",id:"classes",children:[]}],p={toc:u};function m(e){var t=e.components,n=(0,o.Z)(e,s);return(0,a.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"observables"},"Observables"),(0,a.kt)("p",null,'Proxily tracks references state properties referenced while rendering a component.  It then ensures that your component is rendered anytime those particular  state properties change.  You make your state "observable" with ',(0,a.kt)("a",{parentName:"p",href:"../API/observable#makeobservable"},(0,a.kt)("strong",{parentName:"a"},"makeObservable"))," and ask Proxily to track references with ",(0,a.kt)("a",{parentName:"p",href:"../API/observable#useObservable"},(0,a.kt)("strong",{parentName:"a"},"useObservables"))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"class CounterState {  // Your State\n    value = 0;  \n    increment () {this.value++}\n}\n\nconst state = makeObservable({  // Make it observable\n    counter: new CounterState()\n});\n\nfunction Counter({counter} : {counter : CounterState}) {\n    useObservables(); // Track references\n    const {value, increment} = counter;\n    return (\n        <div>\n            <span>Count: {value}</span>\n            <button onClick={increment}>Increment</button>\n        </div>\n    );\n}\n\nfunction App () {\n    return (\n        <Counter counter={state.counter}/>\n    );\n}\n")),(0,a.kt)("p",null,"These two calls, ",(0,a.kt)("strong",{parentName:"p"},"makeObservable")," and ",(0,a.kt)("strong",{parentName:"p"},"useObservables")," are really all you need for basic state management with React.  If you want to see a more complete exampled, head over to the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/selsamman/proxily_react_todo_classic"},"classic redux-style Todo app"),".  Otherwise continue on."),(0,a.kt)("h2",{id:"stores-actions-selectors"},"Stores, Actions, Selectors"),(0,a.kt)("p",null,"Proxily uses standard Javascript language features to define the traditional elements of state management:  "),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Stores")," - A store in Proxily is simply an object that you have made observable and is usually root object in your state.  It may contain cyclic references and you may have multiple observable root objects.  You can create global stores or local stores that are only needed for a single or small group of components. You can pass around the root of the store or any part of the store to your components as properties, contexts or simply import it.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Actions")," - Actions refers to actions that your application make take that modify state.  Any function that is a member of an observable object can be an action.  Proxily tracks the nesting of calls such that the top level function you call is considered to be the action for purposes of tooling and batching of reactions. ")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Selectors")," - A selector is simply a Javascript ",(0,a.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get"},"getter")," method on an observable object.  You may optionally ",(0,a.kt)("a",{parentName:"p",href:"../Features/memoization"},"memoize")," the selector for better performance on expensive calculations (e.g. sorts and filters)."))),(0,a.kt)("p",null,"While the proxily doesn't have a fixed opinion on how you set these up, you should pick a pattern and stick to it so that you have a consistent approach to managing state throughout your application."),(0,a.kt)("h3",{id:"plane-old-javascript"},"Plane Old Javascript"),(0,a.kt)("p",null,'With traditional state management systems such as Redux you create a "plane old javascript" state, define reducers to generate a new state in response to actions that are dispatched to your store.  In Proxily you don\'t need reducers as your actions modify the store directly but you can keep your state as "plain old javascript" and define your actions and selectors separately.'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript",metastring:"jsx",jsx:!0},"    const store = persist({\n        counter: {\n            value: 0\n        }\n    }, {});\n    const actions = makeObservable({\n        increment () {\n            store.counter.value++\n        }\n    })\n    const selectors = makeObservable({\n        get value () {\n            return store.counter.value;\n        }\n    })\n    function App() {\n        useObservables();\n        const {value} = selectors;\n        const {increment} = actions;\n        return (\n            <div>\n                <span>Count: {value}</span>\n                <button onClick={increment}>Increment</button>\n            </div>\n        );\n    }\n")),(0,a.kt)("p",null,"Notice that we added ",(0,a.kt)("strong",{parentName:"p"},"persist")," here to save and restore the state to local storage.  IN addtion to saving and restoring state to local or session storage, ",(0,a.kt)("strong",{parentName:"p"},"persist")," also makes the object retured observable so there is no need for an extra ",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("em",{parentName:"strong"},"makeObservable"))," for the store."),(0,a.kt)("p",null,"In a real application you would define the store, actions and selectors in one or more separate files and import them into the components as needed.  There is no reason to export the store to make sure all updates and references go through your actions and selectors."),(0,a.kt)("h2",{id:"classes"},"Classes"),(0,a.kt)("p",null,"Classes, as was used in the example at the start of this chapter is a more compact way of expressing the problem domain. They are not popular in React simply because no framework, thus far, has made them easy to work with.  In Redux they are, of course, a non-starter and in other frameworks such as mobx they are welcome but still have two downsides:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"You can't easily persist them since the framework doesn't know how to reconstitute them"),(0,a.kt)("li",{parentName:"ul"},'Referencing member functions always requires a object reference to make "this" function correctly.')),(0,a.kt)("p",null,"Proxily takes care of both issues.  Hopefully you spent some time wondering how on earth the first counter example in the chapter worked.  After all we just destructured increment from the counter reference"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"const {value, increment} = counter;\n")),(0,a.kt)("p",null,"and then used it in the input component"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"<button onClick={increment}>Increment</button>\n")),(0,a.kt)("p",null,"You might expect this to fail and then decide as many have that classes are just evil and should be avoided.  It didn't fail because ",(0,a.kt)("strong",{parentName:"p"},"Proxily binds all members in observable functions to the object that referenced them"),". This takes away one of the key pain points of using classes."),(0,a.kt)("p",null,"If you want to persist our counter example we can persist it in "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"    const state = persist({\n        counter: new CounterState()\n    }, {classes: [CounterState]});\n")),(0,a.kt)("p",null,"To reconstitute the state correctly all you need to do is to give persist a list of the classes you use so it can recreate them restoring state."),(0,a.kt)("p",null,'The choice of "plane old javascript" or classes is yours to make.  Proxily makes it possible to use them without the barriers that have kept React programmers away from them in the past. While there is nothing significant that you can\'t do without them, they provide some tangeble advantages:'),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"The state and the code to modify that state are bound together, so it is clear which code is mutating your state.  Private members allow this to be enforced.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"The most compact way to express Typescript types.  You don't have to define interfaces and initial state values.  Combining them means types are usually inferred. ")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"There is one single interface for both consuming and modifying any object in your state.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"You mostly don't need to pass in instance identifiers as parameters to your actions, making for tidier JSX  ",(0,a.kt)("inlineCode",{parentName:"p"},"onClick={toggleTodo}")," vs ",(0,a.kt)("inlineCode",{parentName:"p"},"onClick={()=>toggleTodo(toDo)}"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Class name travels with the data making it possible to log both the class and method when state is mutated. Same for redux-devtools integration."))))}m.isMDXComponent=!0}}]);