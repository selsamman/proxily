"use strict";(self.webpackChunkproxily_doc=self.webpackChunkproxily_doc||[]).push([[46],{3905:function(e,t,r){r.d(t,{Zo:function(){return c},kt:function(){return b}});var n=r(7294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function s(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var i=n.createContext({}),p=function(e){var t=n.useContext(i),r=t;return e&&(r="function"==typeof e?e(t):s(s({},t),e)),r},c=function(e){var t=p(e.components);return n.createElement(i.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,o=e.originalType,i=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=p(r),b=a,m=d["".concat(i,".").concat(b)]||d[b]||u[b]||o;return r?n.createElement(m,s(s({ref:t},c),{},{components:r})):n.createElement(m,s({ref:t},c))}));function b(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=r.length,s=new Array(o);s[0]=d;var l={};for(var i in t)hasOwnProperty.call(t,i)&&(l[i]=t[i]);l.originalType=e,l.mdxType="string"==typeof e?e:a,s[1]=l;for(var p=2;p<o;p++)s[p]=r[p];return n.createElement.apply(null,s)}return n.createElement.apply(null,r)}d.displayName="MDXCreateElement"},3491:function(e,t,r){r.r(t),r.d(t,{frontMatter:function(){return l},contentTitle:function(){return i},metadata:function(){return p},toc:function(){return c},default:function(){return d}});var n=r(7462),a=r(3366),o=(r(7294),r(3905)),s=["components"],l={sidebar_position:1,title:"Observable API"},i=void 0,p={unversionedId:"API/observable",id:"API/observable",isDocsHomePage:!1,title:"Observable API",description:"makeObservable ##",source:"@site/docs/API/observable.md",sourceDirName:"API",slug:"/API/observable",permalink:"/docs/API/observable",editUrl:"https://github.com/selsamman/proxily-doc/edit/master/website/docs/API/observable.md",version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,title:"Observable API"},sidebar:"tutorialSidebar",previous:{title:"Tooling",permalink:"/docs/Features/tools"},next:{title:"Serialize/Persist API",permalink:"/docs/API/serial_persist"}},c=[{value:"makeObservable",id:"makeobservable",children:[]},{value:"useObservables",id:"useobservables",children:[]},{value:"useObservableProp",id:"useobservableprop",children:[]},{value:"observe",id:"observe",children:[]},{value:"memoize",id:"memoize",children:[]},{value:"bindObservables",id:"bindobservables",children:[]}],u={toc:c};function d(e){var t=e.components,r=(0,a.Z)(e,s);return(0,o.kt)("wrapper",(0,n.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"makeobservable"},"makeObservable"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"makeObservable<T>(targetIn: T, transaction? : Transaction) : T\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"makeObservable")," Makes a state object able to detect changes react to them using either ",(0,o.kt)("a",{parentName:"p",href:"#useobservable"},(0,o.kt)("strong",{parentName:"a"},"useObservables"))," or ",(0,o.kt)("a",{parentName:"p",href:"#observe"},(0,o.kt)("strong",{parentName:"a"},"observe")),".  It also enables all other proxily functionality that applies to observable objects such as memoization, function binding, reporting top level calls as actions to redux-devtools.  "),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Item"),(0,o.kt)("th",{parentName:"tr",align:null},"Description"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"targetIn"),(0,o.kt)("td",{parentName:"tr",align:null},"Any object representing state")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"transaction"),(0,o.kt)("td",{parentName:"tr",align:null},"An optional transaction")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"returns"),(0,o.kt)("td",{parentName:"tr",align:null},"A proxy for the targetIn of the same type")))),(0,o.kt)("p",null,"The proxy automatically extends its effect by creating other proxies for objects as they are referenced and replacing the references with a references for a proxy to the object.  This means that an entire tree of state need only be made observable at the root.  Generally makeObservable is used centrally to produce long-lived objects for a store.  In some cases shorter lived observable components may be needed within a component in which case ",(0,o.kt)("strong",{parentName:"p"},"useLocalObservable")," is used."),(0,o.kt)("p",null,"The proxy performs these functions on objects:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Binds methods to the object so they can be used without an object reference"),(0,o.kt)("li",{parentName:"ul"},"Handles the memoization of any methods annotated as being memoized."),(0,o.kt)("li",{parentName:"ul"},"Track references to properties in conjunction with ",(0,o.kt)("strong",{parentName:"li"},"useObservables")," or ",(0,o.kt)("strong",{parentName:"li"},"observe")," to enable reactions such as re-rendering when tracked properties are mutated."),(0,o.kt)("li",{parentName:"ul"},'Considers the top level method call to be an "action" for devtools purposes')),(0,o.kt)("p",null,"Note: makeObservable may be used to take an already observable object and make a new copy of it that is part of a transaction"),(0,o.kt)("h2",{id:"useobservables"},"useObservables"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"useObservables(options? : ObserverOptions) : void\n")),(0,o.kt)("p",null,"Tracks usage of any properties of objects made observable through ",(0,o.kt)("strong",{parentName:"p"},"makeObservable"),".  If any properties referenced during the course of the render are changed the component will be re-rendered.  It will also re-render the component if any child properties of a referenced property are modified.  This is to conform with the immutable conventions for re-rendering when state changes.  Properties that referenced directly in the render code or in any synchronous functions called by the render code are tracked."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"useObservables")," must only be used in a React functional component and must conform to the rules of hooks in terms of always being called in the same order relative to other hooks that may be used by the component.  "),(0,o.kt)("p",null,"See ",(0,o.kt)("a",{parentName:"p",href:"#observe"},"observer")," for more details on the ObserverOptions.  The one that is appropriate for consideration in components is ",(0,o.kt)("strong",{parentName:"p"},"notifyParents"),".  It defaults to false meaning that your component will not re-render because it is observing a parent property and one it's child properties is mutated.  If you set it to true ",(0,o.kt)("inlineCode",{parentName:"p"},"useObservables({notifyParents: true})")," then a reaction paradigm similar to Redux is followed whereby components referencing parent properties are re-rendered even if a chhild orhose properties is mutated.  This could be useful in edge cases where you have child components that are not Proxily-aware and you want to rerender child components any time a property or descendent property is mutated."),(0,o.kt)("h2",{id:"useobservableprop"},"useObservableProp"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"useObservableProp<S>(value: S) : [S, (value: S) => void]\n")),(0,o.kt)("p",null,"Returns an array where the 1st element is a property value and the second a function used to set the property value.  The property is the last one referenced.  By passing a reference to a property in the argument this established the property in the argument as the last reference."),(0,o.kt)("p",null,"Used like this"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"  const [value, setValue] = useObservableProp(counter.value)\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"useObservables")," must be called before calling ",(0,o.kt)("strong",{parentName:"p"},"useObservableProp"),"."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"setValue"))," will be considered an action for tooling such as redux-devtools."),(0,o.kt)("h2",{id:"observe"},"observe"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"observe<T>(targetIn: T, \n            onChange : (target : string, prop : string) => void,  \n            observer? : (target : T) => void,\n            observationOptions? : ObserveOptions) \n            : ObservationContext\n\ninterface ObserverOptionsAll {\n    batch: boolean,\n    delay: number | undefined,\n    notifyParents : boolean\n}\n")),(0,o.kt)("p",null,"Used outside a component to observe state changes.  For example, ",(0,o.kt)("strong",{parentName:"p"},"persist")," uses this internally to detect state changes and save them to local storage"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Item"),(0,o.kt)("th",{parentName:"tr",align:null},"Description"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"targetIn"),(0,o.kt)("td",{parentName:"tr",align:null},"An observable object")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"onChange"),(0,o.kt)("td",{parentName:"tr",align:null},"A function that will be called when state in targetIn or it's descendents change")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"observer"),(0,o.kt)("td",{parentName:"tr",align:null},"A function that is called to reference any properties that are to be observed.  If omitted all changes will be observed")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"observationOptions"),(0,o.kt)("td",{parentName:"tr",align:null},"see below")))),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Option"),(0,o.kt)("th",{parentName:"tr",align:null},"Description"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"batch"),(0,o.kt)("td",{parentName:"tr",align:null},"defaults to true so that updates are batched as ",(0,o.kt)("a",{parentName:"td",href:"../Features/observables#batching-of-reactions"},"described here"),". To disable batching set to false")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"delay"),(0,o.kt)("td",{parentName:"tr",align:null},"defaults to undefined which means that reactions are synchronous.  Set to a time delay if you wish reactions to be debounced to a given time interval in milliseconds")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"notifyParents"),(0,o.kt)("td",{parentName:"tr",align:null},"defaults to false meaning that if a state is mutated, only observers of that property will be notified.  If set to true, observers of parents of the state are also notified as is the case for the immutable paradigm")))),(0,o.kt)("h2",{id:"memoize"},"memoize"),(0,o.kt)("p",null,"Observable objects may have memoized getters or functions through ",(0,o.kt)("strong",{parentName:"p"},"memoize"),".  A memoized function will only be recalculated when any of the state that it consumes changes or when the arguments change."),(0,o.kt)("p",null,"It can be used as a decorator proceeding a member function"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"@memoize()\n")),(0,o.kt)("p",null,"or as a function that accepts a class or object, and it's member function name(s)"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"memoize (obj : any, propOrProps : string | Array<string>)\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"memoize")," can only be used functions that are properties of an observable object and cannot be used to make standalone functions memoized.  There are other libraries suitable for standalone functions."),(0,o.kt)("h2",{id:"bindobservables"},"bindObservables"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"bindObservables<P> (ClassBasedComponent : React.ComponentType<P>) : (args : P) => any\n")),(0,o.kt)("p",null,"Accepts a React class based component as a parameter and creates a function-based high order component that call ",(0,o.kt)("strong",{parentName:"p"},"useObservables")," and render the class based component.  Conceptually the function looks like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"function (props : any) {\n    useObservables();\n    return (\n        <ClassBasedComponent {...props}/>\n    )\n}\n")))}d.isMDXComponent=!0}}]);