"use strict";(self.webpackChunkproxily_doc=self.webpackChunkproxily_doc||[]).push([[46],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return d}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var i=a.createContext({}),p=function(e){var t=a.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(i.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},b=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,i=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),b=p(n),d=r,m=b["".concat(i,".").concat(d)]||b[d]||u[d]||o;return n?a.createElement(m,l(l({ref:t},c),{},{components:n})):a.createElement(m,l({ref:t},c))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,l=new Array(o);l[0]=b;var s={};for(var i in t)hasOwnProperty.call(t,i)&&(s[i]=t[i]);s.originalType=e,s.mdxType="string"==typeof e?e:r,l[1]=s;for(var p=2;p<o;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}b.displayName="MDXCreateElement"},3491:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return i},metadata:function(){return p},toc:function(){return c},default:function(){return b}});var a=n(7462),r=n(3366),o=(n(7294),n(3905)),l=["components"],s={sidebar_position:1,title:"Observable API"},i=void 0,p={unversionedId:"API/observable",id:"API/observable",isDocsHomePage:!1,title:"Observable API",description:"observable ##",source:"@site/docs/API/observable.md",sourceDirName:"API",slug:"/API/observable",permalink:"/docs/API/observable",editUrl:"https://github.com/selsamman/proxily-doc/edit/master/website/docs/API/observable.md",version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,title:"Observable API"},sidebar:"tutorialSidebar",previous:{title:"React 18",permalink:"/docs/Features/concurrent"},next:{title:"Persist & Serialize API",permalink:"/docs/API/serial_persist"}},c=[{value:"observable",id:"observable",children:[]},{value:"observer",id:"observer",children:[]},{value:"useObservableProp",id:"useobservableprop",children:[]},{value:"memoize",id:"memoize",children:[]},{value:"nonObservable",id:"nonobservable",children:[]},{value:"useLocalObservable",id:"uselocalobservable",children:[]},{value:"ObservableProvider",id:"observableprovider",children:[]},{value:"observe",id:"observe",children:[]},{value:"groupUpdates",id:"groupupdates",children:[]}],u={toc:c};function b(e){var t=e.components,n=(0,r.Z)(e,l);return(0,o.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"observable"},"observable"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"observable<T>(targetIn: T, transaction? : Transaction) : T\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"observable")," returns a proxy for a state object that will:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Track references to properties when used ",(0,o.kt)("a",{parentName:"li",href:"#useobservables"},(0,o.kt)("strong",{parentName:"a"},"useObservables")),"."),(0,o.kt)("li",{parentName:"ul"},"React to property changes.  Components that call ",(0,o.kt)("a",{parentName:"li",href:"#useobservables"},(0,o.kt)("strong",{parentName:"a"},"useObservables"))," are re-rendered when properties those components reference are mutated.  "),(0,o.kt)("li",{parentName:"ul"},"Performs tracking and reacting outside of React components using ",(0,o.kt)("a",{parentName:"li",href:"#observe"},(0,o.kt)("strong",{parentName:"a"},"observe"))),(0,o.kt)("li",{parentName:"ul"},"Binds methods to the object, so they can be used without an object reference"),(0,o.kt)("li",{parentName:"ul"},"Handles the memoization of any methods annotated as being memoized."),(0,o.kt)("li",{parentName:"ul"},"Extends this behaviour to referenced object by replacing them proxies.")),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Item"),(0,o.kt)("th",{parentName:"tr",align:null},"Description"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"targetIn"),(0,o.kt)("td",{parentName:"tr",align:null},"Any object representing state")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"transaction"),(0,o.kt)("td",{parentName:"tr",align:null},"An optional transaction")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"returns"),(0,o.kt)("td",{parentName:"tr",align:null},"A proxy for the targetIn of the same type")))),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"observable")," is generally used outside of components at the start of the application to create long-lived observable objects that represent your store.  Observable objects may also be created for shorter live objects, tied to a component using ",(0,o.kt)("a",{parentName:"p",href:"#uselocalobservable"},(0,o.kt)("strong",{parentName:"a"},"useLocalObservable"))),(0,o.kt)("h2",{id:"observer"},"observer"),(0,o.kt)("p",null,"Wraps a component, making it an ","[",(0,o.kt)("strong",{parentName:"p"},"observer"),"]"," so it can react to any changes in referenced properties by rendering. "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"function observer<P>(Component : FunctionComponent<P>, \n         options? : ObserverOptions) : NamedExoticComponent<P>\n")),(0,o.kt)("p",null,"See ",(0,o.kt)("a",{parentName:"p",href:"#observer"},(0,o.kt)("strong",{parentName:"a"},"observe"))," for a description of options though they are rarely needed. "),(0,o.kt)("p",null,"As with other wrappers such as ",(0,o.kt)("strong",{parentName:"p"},"React.memo")," several syntax options are available."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"function Value1 () { s\n    return (<div>{state.value1}</div>);\n}\nexport default observer(Value1)\n")),(0,o.kt)("p",null,"or for exporting named properties:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"export const Value1 = observer(function Value1 () { \n    return (<div>{state.value1}</div>);\n});\n")),(0,o.kt)("p",null,"finally this can be used but it won't preserve the name of the component for debugging:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"export const Value1 = observer(() => { \n    return (<div>{state.value1}</div>);\n});\n")),(0,o.kt)("p",null,"Tracks usage of any observable objects and re-renders the component when any of those properties are mutated.  ",(0,o.kt)("strong",{parentName:"p"},"useObservables")," must only be used in a React functional component.  For class based components use ",(0,o.kt)("a",{parentName:"p",href:"#bindobservables"},(0,o.kt)("strong",{parentName:"a"},"bindObservables")),".  Outside of components use ",(0,o.kt)("a",{parentName:"p",href:"#observe"},(0,o.kt)("strong",{parentName:"a"},"observe")),"."),(0,o.kt)("p",null,"See ",(0,o.kt)("a",{parentName:"p",href:"#observe"},"observer")," for more details on the ",(0,o.kt)("strong",{parentName:"p"},"ObserverOptions"),".  One relevant option,  ",(0,o.kt)("strong",{parentName:"p"},"notifyParents")," can be set to true to force re-rendering even when children of tracked properties are mutated. Can be useful if you have child components that don't know about Proxily but still need to be re-rendered when data changes."),(0,o.kt)("h2",{id:"useobservableprop"},"useObservableProp"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"useObservableProp<S>(value: S) : [S, (value: S) => void]\n")),(0,o.kt)("p",null,"Returns an array where the 1st element is a property value and the second a function used to set the property value.  The property is the last one referenced.  By passing a reference to a property in the argument this established the property in the argument as the last reference."),(0,o.kt)("p",null,"Used like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"  const [value, setValue] = useObservableProp(counter.value)\n")),(0,o.kt)("p",null,"Can only be used in a component wrapped as an ",(0,o.kt)("a",{parentName:"p",href:"#observer"},(0,o.kt)("strong",{parentName:"a"},"observer")),"."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"setValue"))," will be considered an action for tooling such as redux-devtools."),(0,o.kt)("h2",{id:"memoize"},"memoize"),(0,o.kt)("p",null,"Observable objects may have memoized getters or functions through ",(0,o.kt)("strong",{parentName:"p"},"memoize"),".  A memoized function will only be recalculated when any of the state that it consumes changes or when the arguments change."),(0,o.kt)("p",null,"It can be used as a decorator proceeding a member function"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"@memoize()\n")),(0,o.kt)("p",null,"or as a function that accepts a class or object, and it's member function name(s)"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"memoize (obj : any, propOrProps : string | Array<string>)\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"memoize")," can only be used in functions that are properties of an observable object and cannot be used to make standalone functions memoized.  There are other libraries suitable for standalone memoization."),(0,o.kt)("h2",{id:"nonobservable"},"nonObservable"),(0,o.kt)("p",null,"Sometimes you need for Proxily to leave certain properties alone and not create a proxy for them since they don't directly contain state and may function improperly if a proxy is created for them."),(0,o.kt)("p",null,"Two forms of ",(0,o.kt)("strong",{parentName:"p"},"nonObservable")," are allowed for this:"),(0,o.kt)("p",null,"As a decorator proceeding a property"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"@nonObservable()\n")),(0,o.kt)("p",null,"As a function that accepts a class or object, and it's property name(s)"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"nonObservable (obj : any, propOrProps : string | Array<string>)\n")),(0,o.kt)("p",null,"As a function call to nominate either properties of an object or properties of a class as not being observable"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Item"),(0,o.kt)("th",{parentName:"tr",align:null},"Description"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"obj"),(0,o.kt)("td",{parentName:"tr",align:null},"An object or a class")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"propsOrProps"),(0,o.kt)("td",{parentName:"tr",align:null},"An array of property names or a single property name")))),(0,o.kt)("p",null,"In both cases the property will not be made observable.  This is important when objects that don't directly represent state are included in an object that will be made observable."),(0,o.kt)("h2",{id:"uselocalobservable"},"useLocalObservable"),(0,o.kt)("p",null,"Creates an observable object tied to a component life-cycle"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"useLocalObservable<T>(callback : () => T, transaction? : Transaction) : T\n")),(0,o.kt)("p",null,"Creates an observable object when the component mounts.  Generally this is for shorter lived observable objects.  The call back is only invoked once per component life-cycle and returns and object that will be made observable.  Used like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"const sampleListController = useLocalObservable(() => new ListController(sampleToDoList))\n")),(0,o.kt)("h2",{id:"observableprovider"},"ObservableProvider"),(0,o.kt)("p",null,"A component that creates an observable object and places it in a context of your choice.  Useful when iterating in JSX and requiring a new observable object on each iteration."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"ObservableProvider = ({context, value, dependencies, transaction, children} : {\n    context : any, \n    value : Function | any, \n    dependencies : Array<any>, \n    transaction?: Transaction, \n    children: any})\n")),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Options"),(0,o.kt)("th",{parentName:"tr",align:null},"Description"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"context"),(0,o.kt)("td",{parentName:"tr",align:null},"A context created by React.createContext")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"value"),(0,o.kt)("td",{parentName:"tr",align:null},"A callback function that will return an object to be made observable or the object itself")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"dependencies"),(0,o.kt)("td",{parentName:"tr",align:null},"An array of values that will be used to memoized the creation of a new object based when the values change")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"transaction"),(0,o.kt)("td",{parentName:"tr",align:null},"An optional transaction if the observable object is to be part of a transaction")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"children"),(0,o.kt)("td",{parentName:"tr",align:null},"Child components are automatically passed in by using the component in JSX")))),(0,o.kt)("p",null,"Here is an example that creates a new observable object for each todoListItem:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"<ObservableProvider key={index} context={ListItemContext} dependencies={[item]}\n                    value={() => new ListItemController(listController, item)}>\n    <ListItem key={index}/>\n</ObservableProvider>\n")),(0,o.kt)("p",null,"In the component you reference the observable like this"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"    const listItem = useContext(ListItemContext)\n")),(0,o.kt)("p",null,"ListItemContext must be created with React.createContext"),(0,o.kt)("h2",{id:"observe"},"observe"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"observe<T>(targetIn: T, \n            onChange : (target : string, prop : string) => void,  \n            observer? : (target : T) => void,\n            observationOptions? : ObserveOptions) \n            : ObservationContext\n\ninterface ObserverOptionsAll {\n    batch: boolean,\n    delay: number | undefined,\n    notifyParents : boolean\n}\n")),(0,o.kt)("p",null,"Used outside a component to observe state changes.  For example, ",(0,o.kt)("strong",{parentName:"p"},"persist")," uses this internally to detect state changes and save them to local storage"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Item"),(0,o.kt)("th",{parentName:"tr",align:null},"Description"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"targetIn"),(0,o.kt)("td",{parentName:"tr",align:null},"An observable object")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"onChange"),(0,o.kt)("td",{parentName:"tr",align:null},"A function that will be called when state in targetIn, or it's descendents change")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"observer"),(0,o.kt)("td",{parentName:"tr",align:null},"A function that is called to reference any properties that are to be observed.  If omitted all changes will be observed")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"observationOptions"),(0,o.kt)("td",{parentName:"tr",align:null},"see below")))),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Option"),(0,o.kt)("th",{parentName:"tr",align:null},"Description"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"batch"),(0,o.kt)("td",{parentName:"tr",align:null},"defaults to true so that updates are batched as ",(0,o.kt)("a",{parentName:"td",href:"../Features/observables#batching-of-reactions"},"described here"),". To disable batching set to false")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"delay"),(0,o.kt)("td",{parentName:"tr",align:null},"defaults to undefined which means that reactions are synchronous.  Set to a time delay if you wish reactions to be debounced to a given time interval in milliseconds")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"notifyParents"),(0,o.kt)("td",{parentName:"tr",align:null},"defaults to false meaning that if a state is mutated, only observers of that property will be notified.  If set to true, observers of parents of the state are also notified as is the case for the immutable paradigm")))),(0,o.kt)("h2",{id:"groupupdates"},"groupUpdates"),(0,o.kt)("p",null,"Reactions to updates are normally batched such that they occur once per high-level function call.  In async functions this is not the case and so you can force the reactions to be batched by placing them in a ",(0,o.kt)("strong",{parentName:"p"},"groupUpdates")," callback"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"groupUpdates = (callback : Function))\n")),(0,o.kt)("p",null,"Example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"async doSomething () {\n    this.prop1 = 100;\n    await (new Promise((res : any) =>setTimeout(()=>res(), 1000)));\n    groupUpdates( () => {\n        this.prop2 = 200;\n        this.prop3 = 300;\n    })\n}\n")))}b.isMDXComponent=!0}}]);